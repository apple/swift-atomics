//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift Atomics open source project
//
// Copyright (c) 2020 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
// RUN: %empty-directory(%t)
// RUN: %gyb %s -o %t/UnsafeAtomicInitializers.swift
// RUN: %line-directive %t/UnsafeAtomicInitializers.swift -- %target-swift-frontend -typecheck -verify %t/UnsafeAtomicInitializers.swift

%{
  from gyb_utils import autogenerated_warning

  types = [
    # id        type      initial
    ("Int",     "Int",    "0"),
    ("Int64",   "Int64",  "0"),
    ("Int32",   "Int32",  "0"),
    ("Int16",   "Int16",  "0"),
    ("Int8",    "Int8",   "0"),
    ("UInt",    "UInt",   "0"),
    ("UInt64",  "UInt64", "0"),
    ("UInt32",  "UInt32", "0"),
    ("UInt16",  "UInt16", "0"),
    ("UInt8",   "UInt8",  "0"),

    # id             type                          initial
    ("URP",          "UnsafeRawPointer",           "UnsafeRawPointer(UnsafeMutableRawPointer.allocate(byteCount: 8, alignment: 8))"),
    ("UP",           "UnsafePointer<Bar>",         "UnsafePointer(UnsafeMutablePointer<Bar>.allocate(capacity: 1))"),
    ("UMRP",         "UnsafeMutableRawPointer",    ".allocate(byteCount: 8, alignment: 8)"),
    ("UMP",          "UnsafeMutablePointer<Bar>",  ".allocate(capacity: 1)"),
    ("Unmanaged",    "Unmanaged<Foo>",             "Unmanaged.passRetained(Foo())"),

    # id             type                          initial
    ("URPOpt",       "UnsafeRawPointer?",          "nil"),
    ("UPOpt",        "UnsafePointer<Bar>?",        "nil"),
    ("UMRPOpt",      "UnsafeMutableRawPointer?",   "nil"),
    ("UMPOpt",       "UnsafeMutablePointer<Bar>?", "nil"),
    ("UnmanagedOpt", "Unmanaged<Foo>?",            "nil"),
  ]
}%
${autogenerated_warning()}

import Atomics

class Foo {
  var value = 0
}
struct Bar {
  var value = 0
}

% for (id, type, initial) in types:
// swift-format-ignore: AlwaysUseLowerCamelCase
func test_${id}() -> UnsafeAtomic<${type}> {
  var storage = UnsafeAtomic<${type}>.Storage(${initial})
  let atomic = UnsafeAtomic<${type}>(at: &storage)
  // expected-warning {{inout expression creates a temporary pointer, but argument 'at' should be a pointer that outlives the call to 'init(at:)'}}
  // expected-note@-1 {{implicit argument conversion from 'UnsafeAtomic<${type}>.Storage' to 'UnsafeMutablePointer<UnsafeAtomic<${type}>.Storage>' produces a pointer valid only for the duration of the call to 'init(at:)'}}
  // expected-note@-2 {{use 'withUnsafeMutablePointer' in order to explicitly convert argument to pointer valid for a defined scope}}
  return atomic
}
% end

// swift-format-ignore: AlwaysUseLowerCamelCase
func test_UnsafeAtomicLazyReference() -> UnsafeAtomicLazyReference<Foo> {
  var value = UnsafeAtomicLazyReference<Foo>.Storage()
  let atomic = UnsafeAtomicLazyReference(at: &value)
  // expected-warning {{inout expression creates a temporary pointer, but argument 'at' should be a pointer that outlives the call to 'init(at:)'}}
  // expected-note@-1 {{implicit argument conversion from 'UnsafeAtomicLazyReference<Foo>.Storage' to 'UnsafeMutablePointer<UnsafeAtomicLazyReference<Foo>.Storage>' produces a pointer valid only for the duration of the call to 'init(at:)'}}
  // expected-note@-2 {{use 'withUnsafeMutablePointer' in order to explicitly convert argument to pointer valid for a defined scope}}
  return atomic
}

class BrokenAtomicCounter { // THIS IS BROKEN; DO NOT USE
  private var _storage = UnsafeAtomic<Int>.Storage(0)
  private var _value: UnsafeAtomic<Int>?

  init() {
    // This escapes the ephemeral pointer generated by the inout expression,
    // so it leads to undefined behavior when the pointer gets dereferenced
    // in the atomic operations below. DO NOT DO THIS.
    _value = UnsafeAtomic(at: &_storage)
    // expected-warning {{inout expression creates a temporary pointer, but argument 'at' should be a pointer that outlives the call to 'init(at:)'}}
    // expected-note@-1 {{implicit argument conversion from 'UnsafeAtomic<Int>.Storage' to 'UnsafeMutablePointer<UnsafeAtomic<Int>.Storage>' produces a pointer valid only for the duration of the call to 'init(at:)'}}
    // expected-note@-2 {{use 'withUnsafeMutablePointer' in order to explicitly convert argument to pointer valid for a defined scope}}
  }

  func increment() {
    _value!.wrappingIncrement(by: 1, ordering: .relaxed)
  }

  func get() -> Int {
    _value!.load(ordering: .relaxed)
  }
}

struct AtomicCounter {
  typealias Value = Int
  typealias Header = UnsafeAtomic<Value>.Storage

  class Buffer: ManagedBuffer<Header, Void> {
    deinit {
      withUnsafeMutablePointerToHeader { header in
        _ = header.pointee.dispose()
      }
    }
  }

  let buffer: Buffer

  init() {
    buffer = Buffer.create(minimumCapacity: 0) { _ in
      Header(0)
    } as! Buffer
  }

  private func _withAtomicPointer<R>(
    _ body: (UnsafeAtomic<Int>) throws -> R
  ) rethrows -> R {
    try buffer.withUnsafeMutablePointerToHeader { header in
      try body(UnsafeAtomic<Int>(at: header))
    }
  }

  func increment() {
    _withAtomicPointer { $0.wrappingIncrement(ordering: .relaxed) }
  }

  func load() -> Int {
    _withAtomicPointer { $0.load(ordering: .relaxed) }
  }
}

struct AtomicUnmanagedRef<Instance: AnyObject> {
  typealias Value = Unmanaged<Instance>?
  typealias Header = UnsafeAtomic<Value>.Storage

  class Buffer: ManagedBuffer<Header, Void> {
    deinit {
      withUnsafeMutablePointerToHeader { header in
        _ = header.pointee.dispose()
      }
    }
  }

  let buffer: Buffer

  init() {
    buffer = Buffer.create(minimumCapacity: 0) { _ in
      Header(nil)
    } as! Buffer
  }

  private func _withAtomicPointer<R>(
    _ body: (UnsafeAtomic<Value>) throws -> R
  ) rethrows -> R {
    try buffer.withUnsafeMutablePointerToHeader { header in
      try body(UnsafeAtomic<Value>(at: header))
    }
  }

  func store(_ desired: Value) {
    _withAtomicPointer { $0.store(desired, ordering: .sequentiallyConsistent) }
  }

  func load() -> Value {
    _withAtomicPointer { $0.load(ordering: .sequentiallyConsistent) }
  }
}
