//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift Atomics open source project
//
// Copyright (c) 2020 - 2023 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
%{
  from gyb_utils import (
    autogenerated_warning, integerOperations, lowerFirst, argLabel)
}%
${autogenerated_warning()}

#if compiler(>=5.9) && $RawLayout
extension Atomic where Value: AtomicInteger {
  % for (name, _, op, label, doc) in integerOperations:
  /// Perform an atomic ${doc} operation and return the original value, applying
  /// the specified memory ordering.
  ///
  % if "Wrapping" in name:
  /// Note: This operation silently wraps around on overflow, like the
  /// `${op}` operator does on `Int` values.
  ///
  % end
  /// - Parameter operand: An integer value.
  /// - Parameter ordering: The memory ordering to apply on this operation.
  /// - Returns: The original value before the operation.
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public func loadThen${name}(
    ${label} operand: Value${" = 1" if "crement" in name else ""},
    ordering: AtomicUpdateOrdering
  ) -> Value {
    _Storage.atomicLoadThen${name}(
      ${argLabel(label)}operand,
      at: _ptr,
      ordering: ordering)
  }

  % end
  % for (name, _, op, label, doc) in integerOperations:
  /// Perform an atomic ${doc} operation and return the new value, applying
  /// the specified memory ordering.
  ///
  % if "Wrapping" in name:
  /// Note: This operation silently wraps around on overflow, like the
  /// `${op}` operator does on `Int` values.
  ///
  % end
  /// - Parameter operand: An integer value.
  /// - Parameter ordering: The memory ordering to apply on this operation.
  /// - Returns: The new value after the operation.
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public func ${lowerFirst(name)}ThenLoad(
    ${label} operand: Value${" = 1" if "crement" in name else ""},
    ordering: AtomicUpdateOrdering
  ) -> Value {
    let original = _Storage.atomicLoadThen${name}(
      ${argLabel(label)}operand,
      at: _ptr,
      ordering: ordering)
    return original ${op} operand
  }

  % end
  /// Perform an atomic wrapping increment operation applying the
  /// specified memory ordering.
  ///
  /// Note: This operation silently wraps around on overflow, like the
  /// `&+=` operator does on `Int` values.
  ///
  /// - Parameter operand: The value to add to the current value.
  /// - Parameter ordering: The memory ordering to apply on this operation.
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public func wrappingIncrement(
    by operand: Value = 1,
    ordering: AtomicUpdateOrdering
  ) {
    _ = _Storage.atomicLoadThenWrappingIncrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
  }

  /// Perform an atomic wrapping decrement operation applying the
  /// specified memory ordering.
  ///
  /// Note: This operation silently wraps around on overflow, like the
  /// `&-=` operator does on `Int` values.
  ///
  /// - Parameter operand: The value to subtract from the current value.
  /// - Parameter ordering: The memory ordering to apply on this operation.
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public func wrappingDecrement(
    by operand: Value = 1,
    ordering: AtomicUpdateOrdering
  ) {
    _ = _Storage.atomicLoadThenWrappingDecrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
  }
}
#endif

extension UnsafeAtomic where Value: AtomicInteger {
  % for (name, _, op, label, doc) in integerOperations:
  /// Perform an atomic ${doc} operation and return the original value, applying
  /// the specified memory ordering.
  ///
  % if "Wrapping" in name:
  /// Note: This operation silently wraps around on overflow, like the
  /// `${op}` operator does on `Int` values.
  ///
  % end
  /// - Parameter operand: An integer value.
  /// - Parameter ordering: The memory ordering to apply on this operation.
  /// - Returns: The original value before the operation.
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public func loadThen${name}(
    ${label} operand: Value${" = 1" if "crement" in name else ""},
    ordering: AtomicUpdateOrdering
  ) -> Value {
    _Storage.atomicLoadThen${name}(
      ${argLabel(label)}operand,
      at: _ptr,
      ordering: ordering)
  }

  % end
  % for (name, _, op, label, doc) in integerOperations:
  /// Perform an atomic ${doc} operation and return the new value, applying
  /// the specified memory ordering.
  ///
  % if "Wrapping" in name:
  /// Note: This operation silently wraps around on overflow, like the
  /// `${op}` operator does on `Int` values.
  ///
  % end
  /// - Parameter operand: An integer value.
  /// - Parameter ordering: The memory ordering to apply on this operation.
  /// - Returns: The new value after the operation.
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public func ${lowerFirst(name)}ThenLoad(
    ${label} operand: Value${" = 1" if "crement" in name else ""},
    ordering: AtomicUpdateOrdering
  ) -> Value {
    let original = _Storage.atomicLoadThen${name}(
      ${argLabel(label)}operand,
      at: _ptr,
      ordering: ordering)
    return original ${op} operand
  }

  % end

  /// Perform an atomic wrapping increment operation applying the
  /// specified memory ordering.
  ///
  /// Note: This operation silently wraps around on overflow, like the
  /// `&+=` operator does on `Int` values.
  ///
  /// - Parameter operand: The value to add to the current value.
  /// - Parameter ordering: The memory ordering to apply on this operation.
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public func wrappingIncrement(
    by operand: Value = 1,
    ordering: AtomicUpdateOrdering
  ) {
    _ = _Storage.atomicLoadThenWrappingIncrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
  }

  /// Perform an atomic wrapping decrement operation applying the
  /// specified memory ordering.
  ///
  /// Note: This operation silently wraps around on overflow, like the
  /// `&-=` operator does on `Int` values.
  ///
  /// - Parameter operand: The value to subtract from the current value.
  /// - Parameter ordering: The memory ordering to apply on this operation.
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public func wrappingDecrement(
    by operand: Value = 1,
    ordering: AtomicUpdateOrdering
  ) {
    _ = _Storage.atomicLoadThenWrappingDecrement(
      by: operand,
      at: _ptr,
      ordering: ordering)
  }
}

extension ManagedAtomic where Value: AtomicInteger {
  % for (name, _, op, label, doc) in integerOperations:
  /// Perform an atomic ${doc} operation and return the original value, applying
  /// the specified memory ordering.
  ///
  % if "Wrapping" in name:
  /// Note: This operation silently wraps around on overflow, like the
  /// `${op}` operator does on `Int` values.
  ///
  % end
  /// - Parameter operand: An integer value.
  /// - Parameter ordering: The memory ordering to apply on this operation.
  /// - Returns: The original value before the operation.
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public func loadThen${name}(
    ${label} operand: Value${" = 1" if "crement" in name else ""},
    ordering: AtomicUpdateOrdering
  ) -> Value {
    _storage.loadThen${name}(
      ${argLabel(label)}operand,
      ordering: ordering)
  }

  % end

  % for (name, _, op, label, doc) in integerOperations:
  /// Perform an atomic ${doc} operation and return the new value, applying
  /// the specified memory ordering.
  ///
  % if "Wrapping" in name:
  /// Note: This operation silently wraps around on overflow, like the
  /// `${op}` operator does on `Int` values.
  ///
  % end
  /// - Parameter operand: An integer value.
  /// - Parameter ordering: The memory ordering to apply on this operation.
  /// - Returns: The new value after the operation.
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public func ${lowerFirst(name)}ThenLoad(
    ${label} operand: Value${" = 1" if "crement" in name else ""},
    ordering: AtomicUpdateOrdering
  ) -> Value {
    _storage.${lowerFirst(name)}ThenLoad(
      ${argLabel(label)}operand,
      ordering: ordering)
  }

  % end

  /// Perform an atomic wrapping increment operation applying the
  /// specified memory ordering.
  ///
  /// Note: This operation silently wraps around on overflow, like the
  /// `&+=` operator does on `Int` values.
  ///
  /// - Parameter operand: The value to add to the current value.
  /// - Parameter ordering: The memory ordering to apply on this operation.
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public func wrappingIncrement(
    by operand: Value = 1,
    ordering: AtomicUpdateOrdering
  ) {
    _ = _storage.loadThenWrappingIncrement(
      by: operand,
      ordering: ordering)
  }

  /// Perform an atomic wrapping decrement operation applying the
  /// specified memory ordering.
  ///
  /// Note: This operation silently wraps around on overflow, like the
  /// `&-=` operator does on `Int` values.
  ///
  /// - Parameter operand: The value to subtract from the current value.
  /// - Parameter ordering: The memory ordering to apply on this operation.
  @_semantics("atomics.requires_constant_orderings")
  @_transparent @_alwaysEmitIntoClient
  public func wrappingDecrement(
    by operand: Value = 1,
    ordering: AtomicUpdateOrdering
  ) {
    _ = _storage.loadThenWrappingDecrement(
      by: operand,
      ordering: ordering)
  }
}
